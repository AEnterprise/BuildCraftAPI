package buildcraft.api.mj;

import com.google.common.collect.ImmutableSet;

/** Designates the base, simple type that a machine can have. */
public enum MjSimpleType implements IMjConnectorType {
    // Different types of power
    /** The basic, cheap, free power. Generated by redstone engines, and used to do simple things, like extracting stuff
     * from chests or tanks. */
    POWER_REDSTONE,
    /** The proper power - used for doing redstone tasks fast, or more complex tasks like powering a robot or a
     * builder. */
    POWER_KINETIC,
    /** Short-distance wireless transport. */
    POWER_LASER,

    // Redstone top level types -- the most basic 2 categories that redstone machines can fit into
    REDSTONE_PRODUCER(POWER_REDSTONE),
    REDSTONE_CONSUMER(POWER_REDSTONE),
    // REDSTONE_TRANSPORTER; -- by design you cannot transport redstone power

    // Kinetic top level types -- the most basic 3 categories that a machine can fit into
    KINETIC_PRODUCER(POWER_KINETIC),
    KINETIC_CONSUMER(POWER_KINETIC),
    KINETIC_TRANSPORTER(POWER_KINETIC),

    // Laser top level types -- the most basic 3 categories that a machine can fit into
    LASER_PRODUCER(POWER_LASER),
    LASER_CONSUMER(POWER_LASER),
    LASER_TRANSPORTER(POWER_LASER),

    // Different types of producers
    RS_PRODUCER_ENGINE(REDSTONE_PRODUCER),

    KN_PRODUCER_ENGINE(KINETIC_PRODUCER),
    KN_PRODUCER_GENERATOR(KINETIC_PRODUCER),

    // Different types of consumers
    /** A machine that can accept redstone power to get the job done. The most expensive example of this is the pump. */
    RS_CONSUMER_MACHINE(REDSTONE_CONSUMER),

    KN_COSUMER_MACHINE(KINETIC_CONSUMER),

    // Different types of transporters
    KN_TRANSPORT_PIPE(KINETIC_TRANSPORTER),
    /** A storage. Based off of transport as this (by itself) doesn't consume or produce any power - it just transports
     * it through time into the future. */
    KN_TRANSPORT_STORAGE(KINETIC_TRANSPORTER),

    /** Some sort of transporter that teleports between 2 places. */
    KN_TRANSPORT_TELEPORT(KINETIC_TRANSPORTER),

    LA_TRANSPORTER_CONVERT(LASER_TRANSPORTER),

    ;

    /** Stores this, its parents, its parents parents, etc. Basically allows for not recursing when trying to find out
     * if it is a type or not. */
    // Unfortunately we can't use EnumSet as this is done in the initialisers.
    private final ImmutableSet<MjSimpleType> allParents;
    private final MjSimpleType powerType, roleType;

    private MjSimpleType() {
        allParents = ImmutableSet.of();
        powerType = this;
        roleType = null;
        if (ordinal() > 2) {
            // We are not POWER_REDSTONE or POWER_KINETIC
            throw new IllegalStateException("Was not POWER_KINETIC or POWER_REDSTONE! (was " + name() + ")");
        }
    }

    private MjSimpleType(MjSimpleType... parents) {
        ImmutableSet.Builder<MjSimpleType> builder = ImmutableSet.builder();
        for (MjSimpleType type : parents) {
            builder.add(type);
            builder.addAll(type.allParents);
        }
        allParents = builder.build();
        MjSimpleType power = null;
        for (MjSimpleType type : allParents) {
            if (type.powerType == type) {
                if (power == null | power == type) {
                    power = type;
                } else {
                    throw new IllegalStateException("Tried to combine power systems! (Was " + power + ", but tried to make it " + type + ") for " + name());
                }
            }
        }
        powerType = power;

        if (allParents.size() == 1) {
            // It only contains a power type, so this must be a role
            roleType = this;
        } else {
            MjSimpleType role = null;
            for (MjSimpleType type : allParents) {
                if (type.roleType == type) {
                    if (role == null | role == type) {
                        role = type;
                    } else {
                        throw new IllegalStateException("Tried to combine role! (Was " + role + ", but tried to make it " + type + ") for " + name());
                    }
                }
            }
            roleType = role;
        }
    }

    @Override
    public boolean is(IMjConnectorType other) {
        MjSimpleType otherType = other.getSimpleType();
        return this == otherType || allParents.contains(otherType);
    }

    @Override
    public MjSimpleType getSimpleType() {
        return this;
    }

    public MjSimpleType getRole() {
        return roleType;
    }

    public MjSimpleType getPower() {
        return powerType;
    }

    /** Checks to see if this base, simple type can send to another, base simple type.
     * 
     * @param to
     * @return */
    public boolean canSendTo(MjSimpleType to) {
        if (powerType == POWER_REDSTONE) {
            return to.powerType == POWER_REDSTONE;
        } else if (powerType == POWER_KINETIC) {
            return true;
        } else if (powerType == POWER_LASER) {
            return true;
        }

        return false;
    }

    public boolean canReceiveFrom(MjSimpleType from) {
        return from.canSendTo(this);
    }
}
